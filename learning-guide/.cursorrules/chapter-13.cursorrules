# Chapter 13: From Chatbots to Autonomous Agents - Cursor Rules

## Chapter Context

This chapter introduces AI agents - autonomous systems that perceive, think, and act. Students learn the agent loop, build components (perception, memory, reasoning, action), and assemble complete agents. Foundation for all agent work.

## Key Concepts

### 1. Agents vs. Chatbots
- Chatbots: reactive, stateless, no tools, no goals
- Agents: goal-oriented, stateful, use tools, autonomous
- Key difference: agents can act and achieve goals

### 2. Agent Loop (Perceive-Think-Act)
- **Perceive**: Gather information from environment
- **Think**: Process information, reason, decide
- **Act**: Execute actions, affect environment
- Loop continuously until goal achieved

### 3. Agent Components
- **Perception**: Sensors, data gathering, environment monitoring
- **Memory**: State storage, history, goals, context
- **Reasoning**: LLM-based decisions, planning, evaluation
- **Action**: Tools, execution, environment interaction

### 4. Agent Architectures
- Simple reactive agents
- Goal-based agents
- Utility-based agents
- Learning agents
- Multi-agent systems

## Important Code Patterns

### Agent Loop
```python
class Agent:
    def __init__(self):
        self.perception = PerceptionSystem()
        self.memory = MemorySystem()
        self.reasoning = ReasoningEngine()
        self.actions = ActionSystem()
        self.goals = []
    
    def run(self):
        while not self.goals_achieved():
            # Perceive
            observations = self.perception.perceive(environment)
            # Think
            plan = self.reasoning.reason(observations, self.memory, self.goals)
            # Act
            results = self.actions.execute(plan)
            # Update memory
            self.memory.update(observations, results)
```

### Perception System
```python
class PerceptionSystem:
    def __init__(self):
        self.sensors = {}
    
    def register_sensor(self, name, func):
        self.sensors[name] = func
    
    def perceive(self, environment):
        observations = {}
        for name, sensor in self.sensors.items():
            observations[name] = sensor(environment)
        return observations
```

### Memory System
```python
class MemorySystem:
    def __init__(self):
        self.state = {}
        self.history = []
        self.goals = []
    
    def update(self, observations, results):
        self.state.update(observations)
        self.history.append({"observations": observations, "results": results})
    
    def get_context(self):
        return {"state": self.state, "recent_history": self.history[-5:]}
```

### Reasoning Engine
```python
class ReasoningEngine:
    def reason(self, observations, memory, goals):
        context = memory.get_context()
        prompt = f"""
        Observations: {observations}
        Current State: {context['state']}
        Goals: {goals}
        
        What actions should be taken?
        """
        response = ai.call(prompt)
        return parse_actions(response)
```

## Common Mistakes to Avoid

1. **No goals**: Agents need clear goals
2. **No tools**: Agents without tools can't act
3. **No memory**: Agents need state to be effective
4. **Infinite loops**: Always have termination conditions
5. **No error handling**: Agents must handle failures
6. **Over-complicating**: Start simple, add complexity

## Integration Points

- **Chapters 1-12**: Foundation for agents
- **Chapter 14**: Tool use (agents need tools)
- **Chapter 15**: Production agents (extends concepts)
- **Chapter 16**: Multi-agent (extends to multiple agents)

## Related Chapters

- **Chapter 14**: Tool use (agents need tools)
- **Chapter 15**: Production agents (extends concepts)
- **Chapter 16**: Multi-agent systems (multiple agents)
