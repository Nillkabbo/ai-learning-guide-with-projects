# Chapter 15: Building Production-Ready Agents - Cursor Rules

## Chapter Context

This chapter covers production patterns for agents: state management, observability, error handling, and frameworks. Students learn to build resilient, observable, production-grade agents that can run 24/7.

## Key Concepts

### 1. Prototype vs. Production
- Prototypes: in-memory, forgiving, simple
- Production: persistent, resilient, complex
- Failure is inevitable - design for it
- Must handle edge cases

### 2. State Management
- Persist state to survive restarts
- State stores: database, files, Redis
- Load state on startup
- Update state atomically
- State versioning

### 3. Observability
- **Logging**: Structured logs for debugging
- **Metrics**: Performance and health
- **Tracing**: Request flow tracking
- **Monitoring**: Dashboards and alerts

### 4. Error Handling
- Graceful failures
- Retry strategies
- Circuit breakers
- Recovery mechanisms
- Dead letter queues

### 5. Agent Frameworks
- LangChain: popular Python framework
- Framework benefits: structure, tools, patterns
- When to use: complex systems
- When not: simple agents

## Important Code Patterns

### State Persistence
```python
class StateStore:
    def save(self, agent_id, state):
        # Save to database/file
        pass
    
    def load(self, agent_id):
        # Load from database/file
        pass

class ProductionAgent:
    def __init__(self, state_store):
        self.state_store = state_store
        self.state = state_store.load(self.agent_id) or {}
    
    def process(self, task):
        try:
            result = self._do_work(task)
            self.state["last_task"] = task
            self.state_store.save(self.agent_id, self.state)
            return result
        except Exception as e:
            self._handle_error(e)
```

### Observability
```python
import logging
import structlog

logger = structlog.get_logger()

class ProductionAgent:
    def process(self, task):
        logger.info("task_started", task_id=task.id)
        try:
            result = self._do_work(task)
            logger.info("task_completed", task_id=task.id)
            metrics.record_success()
            return result
        except Exception as e:
            logger.error("task_failed", task_id=task.id, error=str(e))
            metrics.record_failure()
            raise
```

### LangChain Agent
```python
from langchain.agents import AgentExecutor, create_react_agent
from langchain_community.llms import Ollama
from langchain.tools import Tool

llm = Ollama(model="llama2")
tools = [Tool(name="get_status", func=get_device_status)]

agent = create_react_agent(llm, tools, prompt)
executor = AgentExecutor(agent=agent, tools=tools)

result = executor.invoke({"input": "Check device T-001"})
```

## Common Mistakes to Avoid

1. **No state persistence**: State lost on restart
2. **No observability**: Can't debug production issues
3. **Poor error handling**: Crashes on failures
4. **No health checks**: Can't monitor agent health
5. **Ignoring frameworks**: Reinventing the wheel

## Integration Points

- **Chapters 13-14**: Agent foundation
- **Chapter 16**: Multi-agent extends patterns
- **Chapter 20**: Scaling uses these patterns
- **Chapter 23**: Monitoring extends observability

## Related Chapters

- **Chapters 13-14**: Agent foundation
- **Chapter 16**: Multi-agent systems
- **Chapter 20**: Scaling
- **Chapter 23**: Monitoring
