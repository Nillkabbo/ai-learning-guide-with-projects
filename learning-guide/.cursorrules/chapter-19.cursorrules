# Chapter 19: AI Application Architecture Patterns - Cursor Rules

## Chapter Context

This chapter covers architectural patterns for AI applications: monoliths vs. microservices, event-driven systems, database choices, and configuration management. Students learn to design production-grade architectures.

## Key Concepts

### 1. Why Architecture Matters
- Variable latency (milliseconds to seconds)
- High resource usage (CPU, GPU, memory)
- Complex state (conversations, context)
- Cost control (every call costs)
- Model versioning (constant updates)
- Resilience (API failures)

### 2. Monolith vs. Microservices
- **Monolith**: Simple, fast, unified, hard to scale
- **Microservices**: Scalable, independent, complex, network overhead
- Start with monolith, evolve to microservices
- AI services often benefit from microservices

### 3. Event-Driven Architecture
- Message buses (Kafka, RabbitMQ, Redis)
- Event producers
- Event consumers
- Decoupled systems
- Scalable and resilient

### 4. Polyglot Persistence
- SQL: Structured, relational data
- NoSQL: Documents, flexible schemas
- Vector DB: Embeddings, semantic search
- Time-series: Metrics, logs
- Use right tool for each data type

### 5. Configuration Management
- Centralized configuration
- Prompt management
- Model versioning
- Key management
- Environment-specific configs

## Important Code Patterns

### Monolith Example
```python
from fastapi import FastAPI
import openai
import redis

app = FastAPI()
client = openai.OpenAI()
cache = redis.Redis()

@app.post("/analyze")
async def analyze(data: dict):
    # All logic in one place
    cached = cache.get(str(data))
    if cached:
        return cached
    result = client.chat.completions.create(...)
    cache.set(str(data), result)
    return result
```

### Event-Driven
```python
from kafka import KafkaProducer, KafkaConsumer

producer = KafkaProducer()
consumer = KafkaConsumer('ai-events')

# Producer
producer.send('ai-events', value=json.dumps(event_data))

# Consumer
for message in consumer:
    event = json.loads(message.value)
    process_event(event)
```

## Common Mistakes to Avoid

1. **Premature microservices**: Start simple, evolve
2. **Wrong database choice**: Use right tool for data type
3. **No configuration management**: Hard to maintain
4. **Tight coupling**: Use events for decoupling
5. **No versioning**: Can't update safely

## Integration Points

- **Chapters 17-18**: Web apps and real-time (apply architecture)
- **Chapter 20**: Scaling (extends architecture)
- **Chapter 25**: Deployment (uses architecture)

## Related Chapters

- **Chapters 17-18**: Web and real-time (apply patterns)
- **Chapter 20**: Scaling (extends architecture)
- **Chapter 25**: Deployment (uses architecture)
