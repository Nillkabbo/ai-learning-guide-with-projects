# Chapter 17: Building AI-Powered Web Applications - Cursor Rules

## Chapter Context

This chapter teaches building web applications that serve AI capabilities. Students learn Flask/FastAPI, file uploads, streaming, SSE, Pydantic validation, and complete web app patterns. Essential for delivering AI to users.

## Key Concepts

### 1. Web API Basics
- Flask: simple, flexible
- FastAPI: modern, async, validation
- REST endpoints
- JSON responses
- Error handling

### 2. File Uploads
- Multipart form data
- Image processing
- PDF handling
- File validation
- Multimodal AI

### 3. Streaming Responses
- Real-time token streaming
- Generator functions
- Response streaming
- Better UX
- Cost efficiency

### 4. Server-Sent Events (SSE)
- Server-to-client streaming
- Real-time updates
- Event protocol
- Connection management
- Reconnection handling

### 5. Pydantic Validation
- Request models
- Response models
- Type safety
- Automatic validation
- API documentation

## Important Code Patterns

### Basic Flask API
```python
from flask import Flask, request, jsonify
import openai

app = Flask(__name__)
client = openai.OpenAI()

@app.route('/ask', methods=['POST'])
def ask_ai():
    data = request.get_json()
    response = client.chat.completions.create(
        model="gpt-4o-mini",
        messages=[{"role": "user", "content": data['question']}]
    )
    return jsonify({"answer": response.choices[0].message.content})
```

### FastAPI with Pydantic
```python
from fastapi import FastAPI, UploadFile
from pydantic import BaseModel

app = FastAPI()

class Question(BaseModel):
    question: str

@app.post("/ask")
async def ask_ai(question: Question):
    response = client.chat.completions.create(...)
    return {"answer": response.choices[0].message.content}
```

### Streaming Response
```python
from fastapi.responses import StreamingResponse

@app.post("/ask-stream")
async def ask_ai_stream(question: Question):
    def generate():
        stream = client.chat.completions.create(..., stream=True)
        for chunk in stream:
            if chunk.choices[0].delta.content:
                yield chunk.choices[0].delta.content
    
    return StreamingResponse(generate(), media_type="text/plain")
```

### SSE
```python
from sse_starlette.sse import EventSourceResponse

@app.get("/events")
async def event_stream():
    async def generate_events():
        while True:
            data = await get_device_update()
            yield {"data": json.dumps(data)}
            await asyncio.sleep(1)
    
    return EventSourceResponse(generate_events())
```

## Common Mistakes to Avoid

1. **No validation**: Always validate inputs
2. **No error handling**: Web APIs need robust errors
3. **Blocking operations**: Use async for I/O
4. **No streaming**: Always stream long responses
5. **No CORS**: Configure CORS for web clients

## Integration Points

- **Chapters 1-16**: All AI concepts apply
- **Chapter 18**: Real-time extends patterns
- **Chapter 19**: Architecture patterns
- **Chapter 20**: Scaling web apps

## Related Chapters

- **Chapter 18**: Real-time applications (extends concepts)
- **Chapter 19**: Architecture patterns
- **Chapter 20**: Scaling (web app scaling)
