# Chapter 28: AI Workflows and Orchestration - Cursor Rules

## Chapter Context

This chapter covers building complex AI workflows using orchestration engines. Students learn DAGs, workflow orchestrators, error recovery, human-in-the-loop patterns, and building complete automated workflows. Essential for complex business processes.

## Key Concepts

### 1. Simple Chains vs. Workflows
- Simple chains: linear, no branching, no error recovery
- Workflows: DAGs, branching, parallelization, error recovery, human approval
- Use workflows for complex business logic

### 2. Directed Acyclic Graphs (DAGs)
- Directed: tasks flow in specific direction
- Acyclic: no loops (ensures completion)
- Nodes = tasks, edges = dependencies
- Topological sort determines execution order

### 3. Workflow Orchestrator
- Task definition (function + dependencies)
- Dependency resolution (topological sort)
- Execution engine (run tasks in order)
- State management (track progress)
- Data passing (output â†’ input)

### 4. Error Recovery
- Retry strategies (exponential backoff)
- Error handling (catch, log, recover)
- Conditional logic (if/else in workflows)
- Fallback tasks (alternative paths)
- Failure recovery (resume from checkpoint)

### 5. Human-in-the-Loop (HITL)
- Approval workflows (human must approve)
- Human input (wait for user input)
- Escalation (notify humans)
- Integration patterns (webhooks, APIs)
- Critical decision points

## Important Code Patterns

### Task Definition
```python
class Task:
    def __init__(self, task_id: str, function: Callable, dependencies: List[str] = None):
        self.id = task_id
        self.function = function
        self.dependencies = set(dependencies or [])
```

### Orchestrator
```python
class WorkflowOrchestrator:
    def __init__(self):
        self.tasks = {}
        self.results = {}
    
    def add_task(self, task: Task):
        self.tasks[task.id] = task
    
    def execute(self):
        # Topological sort
        execution_order = self._topological_sort()
        
        # Execute in order
        for task_id in execution_order:
            task = self.tasks[task_id]
            # Get dependencies' results
            inputs = [self.results[dep] for dep in task.dependencies]
            # Execute task
            result = task.function(*inputs)
            self.results[task_id] = result
```

### Human-in-the-Loop
```python
def wait_for_approval(task_id: str, data: dict) -> bool:
    """Wait for human approval."""
    # Send notification
    send_approval_request(task_id, data)
    
    # Wait for response (poll or webhook)
    while True:
        response = check_approval_status(task_id)
        if response:
            return response.approved
        time.sleep(5)
```

## Common Mistakes to Avoid

1. **Circular dependencies**: DAGs must be acyclic
2. **No error handling**: Workflows will fail
3. **No retries**: Transient errors cause failures
4. **Blocking on humans**: Use async/await or polling
5. **No state management**: Can't resume from failures

## Integration Points

- **Chapter 13-16**: Agents (workflows orchestrate agents)
- **Chapter 27**: RAG (RAG in workflows)
- **Chapter 19**: Architecture (workflow architecture)

## Related Chapters

- **Chapters 13-16**: Agents (workflows orchestrate)
- **Chapter 27**: RAG (RAG in workflows)
- **Chapter 19**: Architecture (workflow architecture)
